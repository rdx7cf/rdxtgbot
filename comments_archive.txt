// Probably it would be a good idea to inherit from Tg::Bot a custom User class in order to save last user's message.
// The temporary solution for saving the users database is done. However it's not that effective as I want. If someone decide to spam the bot with messages, it will permanently be comparing names...
// Most likely I'm gonna use some sort of SQL DB. Or just a text file?

// So I came up with the SQLite solution.
// I have to figure out multithreading.
// What functions should be async? (Control Panel, DB saving, maybe DB syncing)
// Before saving Data, make a backup (boost::filesystem)!
// Maybe it's worth to merge all the commands into onAnyMessage() then use ifs.

// A specific atomic<bool> to stop all threads?
// https://codereview.stackexchange.com/questions/283622/safely-starting-and-stopping-a-thread-owned-by-a-class
// Maybe a custom class which contains a static atomic<bool> flag...
// https://stackoverflow.com/questions/23117354/how-to-stop-an-stdthread-from-running-without-terminating-the-program
// Or just use std::jthread...
// Thread pool is required.


// I have to figure out the multithreading file access. // Done

// What's remaining:
// 0. Write "fast query" function;
// 1. Finish the bot commands;
// 2. Write a database syncing function;
// 3. Finish the control panel.

// Is sync needed if the bot will insert each user separetely?

// Зашёл новый пользователь => INSERT INTO. Создание новой копии базы данных (?)
// Синхронизацию стоит заменить на копирование. Как только в отдельной папки под бэкапы > 5 копий, удалить самую старую.


// НЕОБХОДИМО ДОБАВИТЬ КОЛИЧЕСТВО СООБЩЕНИЙ ОТ ПОЛЬЗОВАТЕЛЯ ПОДРЯД; ПРИ ДОСТИЖЕНИИ ОПРЕДЕЛЁННОГО ИХ КОЛИЧЕСТВА ВЫЧИЩАТЬ

// The program will call request_stop() and then join() for each of the threads.

 // std::cout / std::cin should be used by a SINGLE thread ONLY.

  // 1 min, 8 sec. ??? 3 requests ???

            // Worth looking into Api::sendRequest...
            // tgbot-cpp isn't asynchronous, that's the problem.

            // One day I'll make my personal asynchronous Telegram library...
            // Temporary fix: modifying CurlHttpClient.cpp by adding two curl_easy_setopt instructions and implementing MyHttpClient class.

            // Making _eventHandler->handleMessage() an asynchronous function is a great idea. Now it works almost perfectly.
            // Gotta write a thread pool class to manage threads like a boss.
